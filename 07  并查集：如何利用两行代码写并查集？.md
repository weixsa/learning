### 本资源由 itjc8.com 收集整理
<p data-nodeid="331825" class=""><strong data-nodeid="332188">并查集</strong>是一种树型的数据结构，用于处理一些<strong data-nodeid="332189">不交集（Disjoint Sets）的合并及查询问题</strong>。通常会用到两种操作。</p>
<ul data-nodeid="331826">
<li data-nodeid="331827">
<p data-nodeid="331828">Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</p>
</li>
<li data-nodeid="331829">
<p data-nodeid="331830">Union：将两个子集合并成同一个集合。</p>
</li>
</ul>
<p data-nodeid="331831">因此，这种数据结构称为<strong data-nodeid="332197">并查集</strong>。</p>
<p data-nodeid="331832">在工程中，<strong data-nodeid="332203">并查集往往较多用于数据清理分类等操作</strong>，并且能够以 O(N) 的时间复杂度处理较大的数据量，出现在大厂的面试题中也就不奇怪了。</p>
<p data-nodeid="331833">学完这一讲，你将会收获：</p>
<ul data-nodeid="331834">
<li data-nodeid="331835">
<p data-nodeid="331836">并查集的模板代码</p>
</li>
<li data-nodeid="331837">
<p data-nodeid="331838">如何利用并查集解决<strong data-nodeid="332211">连通域</strong>问题</p>
</li>
<li data-nodeid="331839">
<p data-nodeid="331840">如何利用虚拟点与虚拟边</p>
</li>
<li data-nodeid="331841">
<p data-nodeid="331842">如何利用路径压缩的技巧</p>
</li>
</ul>
<h3 data-nodeid="331843">并查集基础</h3>
<p data-nodeid="331844">首先来看一下并查集要解决的问题，主要有两个。</p>
<ul data-nodeid="331845">
<li data-nodeid="331846">
<p data-nodeid="331847">Find：查询 item 属于<strong data-nodeid="332220">哪个集合</strong></p>
</li>
<li data-nodeid="331848">
<p data-nodeid="331849">Union：将两个集合<strong data-nodeid="332225">进行合并</strong></p>
</li>
</ul>
<p data-nodeid="331850">我们以一个有趣的问题展开。在《倚天屠龙记》这部武侠小说中，有很多帮派，比如：</p>
<p data-nodeid="331851"><img src="https://s0.lgstatic.com/i/image6/M01/21/80/Cgp9HWBUZN2AGezPAABjCi7FK4I525.png" alt="Drawing 0.png" data-nodeid="332229"></p>
<p data-nodeid="331852">其中张无忌、谢逊、韦一笑属于明教，而张三丰、莫声谷、宋远桥属于武当派。</p>
<h4 data-nodeid="331853">方法 1</h4>
<p data-nodeid="331854">我们首先设计这样一种方案：采用数组/哈希的方法，记录每个人所在的门派。伪代码如下：</p>
<pre class="lang-java" data-nodeid="331855"><code data-language="java"><span class="hljs-comment">// 伪代码</span>
Map&lt;String, String&gt; = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
H[<span class="hljs-string">"谢逊"</span>] = <span class="hljs-string">"明教"</span>
H[<span class="hljs-string">"张无忌"</span>] = <span class="hljs-string">"明教"</span>
H[<span class="hljs-string">"韦一笑"</span>] = <span class="hljs-string">"明教"</span>
H[<span class="hljs-string">"莫声谷"</span>] = <span class="hljs-string">"武当"</span>
H[<span class="hljs-string">"张三丰"</span>] = <span class="hljs-string">"武当"</span>
H[<span class="hljs-string">"宋远桥"</span>] = <span class="hljs-string">"武当"</span>
</code></pre>
<p data-nodeid="331856">那么就可以这样查询：</p>
<pre class="lang-java" data-nodeid="331857"><code data-language="java"><span class="hljs-function">String <span class="hljs-title">Find</span><span class="hljs-params">(String person)</span> </span>{
  <span class="hljs-keyword">return</span> H.get(person);
}
</code></pre>
<p data-nodeid="331858">至此，我们已经完成一个功能了。时间复杂度也很低，可以达到 O(1)。</p>
<p data-nodeid="331859">那我们再看一下合并。假设某一天，张三丰要闭关修炼，决定将武当派暂时交给张无忌代管理，为了方便管理两个帮派，张无忌号令明教的人前往武当派。那么此时就需要进行一个合并 Union 操作，也就是将所有“明教”的人归入“武当”。代码如下：</p>
<pre class="lang-java" data-nodeid="331860"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(String A, String B)</span> </span>{
  <span class="hljs-keyword">for</span> (item : H) {
    <span class="hljs-keyword">if</span> item.value == <span class="hljs-string">"明教"</span>:
      item.value = <span class="hljs-string">"武当"</span>
  }
}
</code></pre>
<p data-nodeid="331861">但是如此一来，整个时间复杂度就上去了，Union 的时候，时间复杂度变成 O(N)。如果 Union 操作很频繁，那么这种算法就变得不可接受。</p>
<h4 data-nodeid="331862">方法 2</h4>
<p data-nodeid="331863">在这里我们换一种思路，看看能不能解决 Union 复杂度过高的问题。采用江湖中通常的做法，认帮主！当帮主一样的时候，就认为我们是一个帮派的。</p>
<p data-nodeid="331864"><img src="https://s0.lgstatic.com/i/image6/M01/21/7D/CioPOWBUZOaADgCUAABGlTOU4Ak099.png" alt="Drawing 1.png" data-nodeid="332241"></p>
<p data-nodeid="331865">每个人都指向自己的大哥，帮主最牛，指向帮主自己。那么要进行 Union 操作的时候。直接修改指针就可以了。代码如下：</p>
<pre class="lang-java" data-nodeid="331866"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(String A, String B)</span> </span>{
  String A帮主 = Find(A);
  String B帮主 = Find(B);
  H.put(A帮主, B帮主); <span class="hljs-comment">// 成功将A所在帮派归入B帮派</span>
}
</code></pre>
<p data-nodeid="331867">在 Union 的最后，我们只需要将 A 帮主指向 B 帮主就可以了。比如，将明教与武当合并，如下图所示：</p>
<p data-nodeid="331868"><img src="https://s0.lgstatic.com/i/image6/M01/21/80/Cgp9HWBUZO6APF37AABG3_a_Q6c057.png" alt="Drawing 2.png" data-nodeid="332246"></p>
<p data-nodeid="331869">我们再看一下 Find 函数，代码如下：</p>
<pre class="lang-java" data-nodeid="331870"><code data-language="java"><span class="hljs-comment">// 返回A的帮主</span>
<span class="hljs-function">String <span class="hljs-title">Find</span><span class="hljs-params">(String A)</span> </span>{
  <span class="hljs-keyword">while</span> (A != H.get(A)) {
    <span class="hljs-comment">// 如果我还有大哥，那么就顺着大哥一路往上找</span>
    A = H.get(A);
  }
  <span class="hljs-comment">// 最终找到了帮主</span>
  <span class="hljs-keyword">return</span> A;
}
</code></pre>
<p data-nodeid="331871">虽然这种办法在 Union 时比较方便，但是在 Find 时却容易引入较高的复杂度。下面我们一起来看一下为什么 Find 起来比较麻烦：</p>
<p data-nodeid="331872"><img src="https://s0.lgstatic.com/i/image6/M01/21/7D/CioPOWBUZQSANG0HAAUZirp5p1k748.gif" alt="1 (1).gif" data-nodeid="332251"></p>
<p data-nodeid="331873">在这种情况下，Find 查询时，总是会查询很多次 O(N)。也就是说，Union 的时间复杂度较低的时候，Find 的时间复杂度又上升了。</p>
<p data-nodeid="331874">那么，有没有更好一点的办法呢？能让 Union 和 Find 的时间复杂度都低一点。</p>
<h4 data-nodeid="331875">路径压缩</h4>
<p data-nodeid="331876">办法还是有的，就叫<strong data-nodeid="332260">路径压缩</strong>，我们发现，在方法 2 中，如果能将层级结构“拍扁”，那么 Find 和 Union 的时间复杂度都会特别低。</p>
<p data-nodeid="331877">因此，我们还需要在 Find 函数里面做一些手脚。当我们找到一帮主之后，就把这条路径上的所有人的大哥都改成帮主。代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="331878"><code data-language="java"><span class="hljs-function">String <span class="hljs-title">Find</span><span class="hljs-params">(String A)</span> </span>{
  <span class="hljs-comment">// start记为出发点</span>
  String start = A;
  <span class="hljs-keyword">while</span> (A != H.get(A)) {
    A = H.get(A);
  }
  <span class="hljs-comment">// 此时A是帮主</span>
  <span class="hljs-comment">// 我们再从出发点开始，把每个人的大哥改成帮主</span>
  <span class="hljs-comment">// 路径压缩的关键代码</span>
  <span class="hljs-keyword">while</span> (H.get(start) != A) {
    String next = H.get(start);
    H.put(start, A);
    start = next;
  }
  <span class="hljs-keyword">return</span> A;
}
</code></pre>
<p data-nodeid="331879">再看这个例子：经过合并，成立糖葫芦帮之后。如下图所示：</p>
<p data-nodeid="331880"><img src="https://s0.lgstatic.com/i/image6/M00/23/F4/CioPOWBX_4mAPpHfAABECA7Vc3g627.png" alt="image.png" data-nodeid="332265"></p>
<p data-nodeid="331881">如果一旦执行 Find("韦一笑")，那么糖葫芦帮派就会变成大饼帮派。</p>
<p data-nodeid="331882"><img src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZgaAOFDCAABeZqcuW0s773.png" alt="Drawing 6.png" data-nodeid="332273"></p>
<p data-nodeid="331883">所有人的帮主都会指向张三丰。也就是说，除了第一次 Find 复杂度为 O(N)，后面的查询复杂度都是 O(1)。至此，我们已经讲清楚带路径压缩的并查集的原理。接下来我们看代码如何实现。</p>
<h3 data-nodeid="331884">并查集模板</h3>
<p data-nodeid="331885">前面使用的都是比较形式化的语言和伪代码。接下来我们看一下具体如何实现并查集。这里我<strong data-nodeid="332281">以整数替换前面的人名</strong>，操作起来更加方便。</p>
<h4 data-nodeid="331886">初始化</h4>
<p data-nodeid="331887">首先假设有 N 个整数，范围为 [0, N)。那么记录每个人的信息，就需要一个长度为 N 的数组。</p>
<pre class="lang-java" data-nodeid="331888"><code data-language="java"><span class="hljs-keyword">int</span> F[N]; <span class="hljs-comment">// 记录每个人的大哥是谁</span>
</code></pre>
<p data-nodeid="331889">在初始化的时候，每个人都是自成一派。</p>
<pre class="lang-java" data-nodeid="331890"><code data-language="java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
  F[i] = i;
}
</code></pre>
<h4 data-nodeid="331891">查询</h4>
<p data-nodeid="331892">根据前面所讲，可以得到查询操作的代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="331893"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-comment">// 查找根结点</span>
  <span class="hljs-keyword">int</span> b = x;
  <span class="hljs-keyword">while</span> (F[x] != x) {
    x = F[x];
  }
  <span class="hljs-comment">// 路径压缩的实现</span>
  <span class="hljs-comment">// 将路径上的每个点指向根结点x</span>
  <span class="hljs-keyword">while</span> (F[b] != x) {
    <span class="hljs-keyword">int</span> p = F[b];
    F[b] = x;
    b = p;
  }
  <span class="hljs-keyword">return</span> x;
}
</code></pre>
<h4 data-nodeid="331894">合并</h4>
<p data-nodeid="331895">完成查询操作，我们就要把两个集合进行合并，代码如下：</p>
<pre class="lang-java" data-nodeid="331896"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  F[find(x)] = find(y);
}
</code></pre>
<p data-nodeid="331897">这两个函数的代码还是显得有点长，并且不太容易记。我在刷题和面试时，更喜欢，或者说常用一份精简过的代码。下面我将分享给你。</p>
<h4 data-nodeid="331898">两行代码</h4>
<p data-nodeid="331899">这里我整理了：<strong data-nodeid="332301">两行</strong>并查集核心代码模板（用 C 语言实现，<strong data-nodeid="332302">方便记忆）：</strong></p>
<pre class="lang-c++" data-nodeid="331900"><code data-language="c++"><span class="hljs-keyword">int</span> F[N];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
 <span class="hljs-keyword">return</span> x == F[x] ? x : F[x] = Find(F[x]); <span class="hljs-comment">// &lt;-- 1. 查找</span>
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  F[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y); <span class="hljs-comment">// &lt;- 2. 合并</span>
}
</code></pre>
<p data-nodeid="331901">注：根据不同的语言，你可能需要修改不同的 Find 函数。</p>
<h4 data-nodeid="331902">两个功能</h4>
<p data-nodeid="331903">当真正使用并查集的时候，面试官可能会问你两个问题：</p>
<ul data-nodeid="331904">
<li data-nodeid="331905">
<p data-nodeid="331906">有多少个集合？</p>
</li>
<li data-nodeid="331907">
<p data-nodeid="331908">每个集合里面有多少个元素？</p>
</li>
</ul>
<p data-nodeid="331909">下面我们依次回答这两个问题。</p>
<p data-nodeid="331910"><strong data-nodeid="332317">1</strong>. <strong data-nodeid="332318">集合数目</strong>：在执行 Find 的时候，集合个数不可能有变化。如果发生变化，只可能发生在两个集合合并的时候。</p>
<p data-nodeid="331911">再来具体看一下初始化和合并操作。</p>
<ul data-nodeid="331912">
<li data-nodeid="331913">
<p data-nodeid="331914">初始化：在并查集开始初始化的时候，一共有 N 个元素，那么一开始集合个数为 N。</p>
</li>
<li data-nodeid="331915">
<p data-nodeid="331916">合并：合并的时候，需要查看合并的两个集合是不是同一个，如果不是，那么集合个数减 1。<br>
<strong data-nodeid="332331">2</strong>. <strong data-nodeid="332332">每个集合中元素的个数</strong>：在执行 Find 的时候，每个集合中元素的个数不可能发生变化。如果发生变化，只可能是两个集合合并的时候。</p>
</li>
</ul>
<p data-nodeid="331917">下面我们具体看一下初始化和合并操作。</p>
<ul data-nodeid="331918">
<li data-nodeid="331919">
<p data-nodeid="331920">初始化：在并查集开始初始化的时候，每个元素都属于独立的元素，那么一开始每个集合里面的个数都是 1。如果我们用 Count[] 数组记录每个元素的个数，那么一开始初始化 Count[] = 1。</p>
</li>
<li data-nodeid="331921">
<p data-nodeid="331922">合并：当 A 集合要合并到 B 集合里面的时候，可以认为 A 集合里面所有的元素都变成 B 集合里面的元素。当然是 B 集合里面的个数增加了，那么 Count[Find(B)] + = Count[Find(A)]。</p>
</li>
</ul>
<p data-nodeid="331923"><strong data-nodeid="332370">注意</strong>：在记录集合中元素个数的时候，<strong data-nodeid="332371">只有根结点的信息是准确的</strong>。当查询结点i所属集合的信息时，只能使用 Count[Find(i)]，而不能使用 Count[i]。因为如果要保证每个点 Count[i] 的信息都是准确的，那么每次合并的时候，整个集合中的元素的信息都要更新，这样时间复杂度就很高了，Union 操作的时间复杂度就不再是O(lgN)，而变成O(N)。</p>
<p data-nodeid="331924">为了方便你刷题和应对面试，这里我给出了并查集的完整代码，你可以作为参考。</p>
<h4 data-nodeid="331925">完整 Java 代码</h4>
<pre class="lang-java" data-nodeid="331926"><code data-language="java"><span class="hljs-comment">// 并查集数组</span>
<span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
<span class="hljs-comment">// 记录并查集中集合的个数</span>
<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
<span class="hljs-comment">// 记录集合中点的个数，比如要知道i所在集合的点有多少个: C[Find(i)]</span>
<span class="hljs-comment">// 注意：这里不能直接使用C[i]</span>
<span class="hljs-comment">// 因为只有根结点的统计才是正确的</span>
<span class="hljs-keyword">int</span>[] Cnt = <span class="hljs-keyword">null</span>;
<span class="hljs-comment">// 并查集的初始化</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
  Cnt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    F[i] = i;
    Cnt[i] = <span class="hljs-number">1</span>;
  }
  count = n;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">if</span> (x == F[x]) {
    <span class="hljs-keyword">return</span> x;
  }
  F[x] = Find(F[x]);
  <span class="hljs-keyword">return</span> F[x];
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  <span class="hljs-keyword">int</span> xpar = Find(x);
  <span class="hljs-keyword">int</span> ypar = Find(y);
  <span class="hljs-comment">// 将x所在集合，合并到y所在集合</span>
  <span class="hljs-keyword">if</span> (xpar != ypar) {
    F[xpar] = ypar;
    <span class="hljs-comment">// y集合里面的个数要增加</span>
    Cnt[ypar] += Cnt[xpar];
    count--;
  }
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
  <span class="hljs-keyword">return</span> Cnt[Find(i)];
}
</code></pre>
<p data-nodeid="331927">注：这里是以<strong data-nodeid="332383">整数</strong>和<strong data-nodeid="332384">数组</strong>为例。如果关键字是 String，也可以使用哈希表将字符串映射到整数再进行并查集的操作。</p>
<blockquote data-nodeid="331928">
<p data-nodeid="331929">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332388">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332392">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332396">Python</a></p>
</blockquote>
<p data-nodeid="331930"><strong data-nodeid="332401">复杂度分析</strong>：并查集的初始化时间复杂度为 O(N)，而 Find 和 Union 的操作时间复杂度都是 O(lgN)，其中 N 为点的总数。这里只使用了长度为 N 的数组，所以空间复杂度为 O(2N)。</p>
<h4 data-nodeid="331931">例 1：最小生成树</h4>
<p data-nodeid="331932">【<strong data-nodeid="332408">题目</strong>】给定一个图的点集，边集和权重，返回构建最小生成树的代价。</p>
<p data-nodeid="331933">输入：N = 2， conn = [[1, 2, 37], [2, 1, 17], [1, 2, 68]]</p>
<p data-nodeid="331934">输出：17</p>
<p data-nodeid="331935"><strong data-nodeid="332435">解释</strong>：图中只有两个点 [1, 2]，当然是选择最小连接 [2, 1, 17]</p>
<p data-nodeid="333495" class="">【<strong data-nodeid="333509">分析</strong>】利用并查集 + 贪心算法，可以生成一个图的<strong data-nodeid="333511">最小生成树，<strong data-nodeid="333510">这种方法也被称为</strong> Kruskal 算法</strong>。并查集可以用来将两个点进行 Union，不过在并查集的 Union 代码中，并没有权重这一项，那我们该怎么办呢？</p>

<p data-nodeid="331937">在 Union 的时候，就直接根据边的权重来排序，然后再处理，这不就是经典的 <strong data-nodeid="332457">Kruskal 算法</strong>。</p>
<p data-nodeid="331938">这里我们可以讲一下最小生成树的思路：</p>
<ul data-nodeid="331939">
<li data-nodeid="331940">
<p data-nodeid="331941">首先初始化并查集</p>
</li>
<li data-nodeid="331942">
<p data-nodeid="331943">将边集<strong data-nodeid="332464">按照权重排序</strong></p>
</li>
<li data-nodeid="331944">
<p data-nodeid="331945">利用边集将不同的两点进行 Union</p>
</li>
<li data-nodeid="331946">
<p data-nodeid="331947">将不同的集合进行 Union 时需要加上新加入的边的代价（即边的权重）。</p>
</li>
</ul>
<p data-nodeid="331948">【<strong data-nodeid="332472">代码</strong>】这里我们可以写出经典的 Kruskal 算法，代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="331949"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> cost = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 这里直接申请了足够多的内存</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
  <span class="hljs-comment">// 并查集初始化</span>
  <span class="hljs-comment">// 注意点的编号是从0 ~ n-1</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
      F[i] = i;
    }
    cost = <span class="hljs-number">0</span>;
  }
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x == F[x]) {
      <span class="hljs-keyword">return</span> x;
    }
    F[x] = Find(F[x]);
    <span class="hljs-keyword">return</span> F[x];
  }
  <span class="hljs-comment">// 在合并的时候，需要加上代价</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> pay)</span> </span>{
    <span class="hljs-keyword">if</span> (Find(x) != Find(y)) cost += pay;
    F[Find(x)] = Find(y);
  }
  <span class="hljs-comment">// 一共有n个点，编号从1~n</span>
  <span class="hljs-comment">// conn表示输入的边的集合</span>
  <span class="hljs-comment">// 每一项是一个三元组[点a, 点b, 需要费用c]</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[][] conn)</span> </span>{
    Init(n);
    <span class="hljs-comment">// 边集的排序</span>
    Arrays.sort(conn, <span class="hljs-number">0</span>, m, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() {
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>{
        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] - b[<span class="hljs-number">2</span>];
      }
    });
    <span class="hljs-comment">// 顺次将边集添加到集合中</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
      Union(conn[i][<span class="hljs-number">0</span>], conn[i][<span class="hljs-number">1</span>], conn[i][<span class="hljs-number">2</span>]);
    }
    <span class="hljs-keyword">return</span> cost;
  }
}
</code></pre>
<blockquote data-nodeid="331950">
<p data-nodeid="331951">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/P1287.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332476">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/P1287.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332480">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/P1287.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332484">Python</a></p>
</blockquote>
<p data-nodeid="331952"><strong data-nodeid="332489">复杂度分析</strong>：程序主要分为两块，一部分为边集 E 的排序，复杂度为 O(ElgE)；另外一部分为每条边的 Union 操作，复杂度为 O(ElgN)。在大部分时候，边的数目往往比点的数目要多，因此时间复杂度为 O(ElgE)。</p>
<p data-nodeid="331953">【<strong data-nodeid="332495">小结</strong>】本质上 Kruskal 算法就是并查集算法 + 贪心算法。使用 Kruskal 算法有一个很重要的前提——题目是假设输入边能将所有的点加到一个连通域中，也就是保证最后必然能够生成一棵树。</p>
<p data-nodeid="331954">这里给你留一道练习题，你可以利用它检验和巩固自己的学习成果。</p>
<p data-nodeid="331955"><strong data-nodeid="332503">练习题 1</strong>：给定点集和边集，求最小生成树的代价，如果最后不能生成最小生成树，那么返回MAX_INT。</p>
<blockquote data-nodeid="331956">
<p data-nodeid="331957">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%BB%A3%E4%BB%B7.md?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332507">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%BB%A3%E4%BB%B7.md?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332511">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%BB%A3%E4%BB%B7.md?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332515">Python</a></p>
</blockquote>
<p data-nodeid="331958">接下来我们一起看一下关于并查集的其他考察形式与考点。</p>
<h3 data-nodeid="331959">连通域的数目</h3>
<p data-nodeid="331960">我们可以把最小生成树当成一个连通域，只不过需要用最小的代价来生成这么一个连通域。除了求解最小生成树，并查集的另外一个常见的用途是求解连通域的数目。在<strong data-nodeid="332523">微软和 EMC</strong> 的面试中都出现过，但是可能会通过两种方式给出图的结构，比如：</p>
<ul data-nodeid="331961">
<li data-nodeid="331962">
<p data-nodeid="331963">点集和边集，告诉你有哪些点，以及哪些边；</p>
</li>
<li data-nodeid="331964">
<p data-nodeid="331965">矩阵表示。</p>
</li>
</ul>
<p data-nodeid="331966">不管是通过哪一种图表示，利用<strong data-nodeid="332531">并查集解决连通域数目的步骤都是以下两步</strong>：</p>
<ol data-nodeid="331967">
<li data-nodeid="331968">
<p data-nodeid="331969">用 F[] 数组和点集进行初始化</p>
</li>
<li data-nodeid="331970">
<p data-nodeid="331971">利用边集进行 Union</p>
</li>
</ol>
<p data-nodeid="331972">最后的集合数目就是连通域的数目。</p>
<p data-nodeid="331973">利用本讲前面学过的模板和思路，相信你已经可以解决面试中的高频出现的算法题了。</p>
<h4 data-nodeid="331974">例 2：帮派的数目</h4>
<p data-nodeid="331975">【<strong data-nodeid="332551">题目</strong>】江湖上有 N 个人，编号从 [1 ~ N]，现在只能告诉你，其中两人是一个帮派的，请你输出帮派的数目。</p>
<p data-nodeid="331976">输入：N = 4, [[1, 2], [2,3]]</p>
<p data-nodeid="331977">输出：2</p>
<p data-nodeid="331978"><strong data-nodeid="332575">解释</strong>：一共有 4 个人，[1,2, 3] 成为一个帮派，[4] 独自成为一个帮派，那么一共有 2 个帮派。</p>
<p data-nodeid="331979">【<strong data-nodeid="332581">分析</strong>】在一开始，你可以认为他们都是独自成为一个帮派，当告诉你每两个人是一个帮派时，相当于要把这两个人合并到一个集合中。问题是一共有多少个帮派，显然这就是一个非常标准的并查集的问题了。我们可以直接套用前面所讲的并查集的模板进行求解。</p>
<p data-nodeid="331980">【<strong data-nodeid="332587">代码</strong>】直接利用并查集的代码模板，代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="331981"><code data-language="java"><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
    F[i] = i;
  }
  count = n;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">if</span> (x == F[x]) {
    <span class="hljs-keyword">return</span> x;
  }
  F[x] = Find(F[x]);
  <span class="hljs-keyword">return</span> F[x];
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  <span class="hljs-keyword">if</span> (Find(x) != Find(y))
    count--;
  F[Find(x)] = Find(y);
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findGangNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] conn)</span> </span>{
  Init(n);
  <span class="hljs-keyword">int</span> m = conn.length;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
    Union(conn[i][<span class="hljs-number">0</span>], conn[i][<span class="hljs-number">1</span>]);
  }
  <span class="hljs-comment">// 帮派里面帮主的个数</span>
  <span class="hljs-keyword">return</span> count;
}
</code></pre>
<blockquote data-nodeid="331982">
<p data-nodeid="331983">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/T1260.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332591">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/T1260.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332595">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/T1260.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332599">Python</a><br>
<strong data-nodeid="332605">复杂度分析</strong>：整个算法的时间复杂度为 O(mlogN) ，这里 n 表示人的数目，而 m 表示两两成对的输入数目。</p>
</blockquote>
<p data-nodeid="331984">【<strong data-nodeid="332611">小结</strong>】在这里我们直接利用并查集的模板搞定了一道题目。</p>
<p data-nodeid="331985"><strong data-nodeid="332616">延伸</strong>：如果将这里的每个点都当成一个“图”结构中的一个点，将两两成对的输入当成“图”结构中的边。那么问题就变成了求解图的连通域个数。</p>
<p data-nodeid="331986">下面我们一起来看一下这个曾经在<strong data-nodeid="332622">微软</strong>的电面中出现的 2 道题目。</p>
<p data-nodeid="331987"><strong data-nodeid="332635">练习题 2</strong>：给定一个黑白图像，其中白色像素用 '1' 表示，黑色像素用 '0' 表示。如果把上下左右相邻的白色像素看成一个连通域，给定一幅图（用矩阵表示），请问图中有几个连通域。</p>
<p data-nodeid="331988">输入：A = [['1', '1', '0'], ['0', '1', '0']]</p>
<p data-nodeid="331989">输出：1</p>
<p data-nodeid="331990"><strong data-nodeid="332675">解释</strong>：图中所有的 '1' 都是连在一起的，所以只有一个连通域。</p>
<blockquote data-nodeid="331991">
<p data-nodeid="331992">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332679">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332683">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332687">Python</a></p>
</blockquote>
<p data-nodeid="331993"><strong data-nodeid="332699">练习题 3</strong>：给定一个图（不是图像）的矩阵，A[i][j] = 1 表示点 i 与点 j 相连，求这个图里面连通域的数目。</p>
<p data-nodeid="331994">输入：A = [[1,0,0],[0,1,0],[0,0,1]]</p>
<p data-nodeid="331995">输出：3</p>
<p data-nodeid="331996"><strong data-nodeid="332723">解释</strong>：[0, 1, 2] 三个点中，每个点都不与其他点相连，所以连通域有 3 个。</p>
<blockquote data-nodeid="331997">
<p data-nodeid="331998">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332727">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332731">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332735">Python</a></p>
</blockquote>
<h4 data-nodeid="331999">例 3: 换工位</h4>
<p data-nodeid="332000">【<strong data-nodeid="332767">题目</strong>】因为要实施结对编程，想让两个员工的工位挨在一起：要求 [0,1] 员工坐在一起，[2, 3] 员工坐在一起，以此类推。不过挨着具体坐的位置并不重要，只要能挨在一起就可以了。比如 [0, 1, 3, 2] 与 [2, 3, 1, 0] 都是满足要求的。现在给定一个数组 A[]，求换工位的最少次数，尽量让两个员工坐在一起。（给定 N 个员工，他们的编号总是 [0~N-1] ，并且 N 总是偶数）。</p>
<p data-nodeid="332001">输入：A[] = [0, 3, 2, 1]</p>
<p data-nodeid="332002">输出：1</p>
<p data-nodeid="332003"><strong data-nodeid="332780">解释</strong>：只需要换 1 次就可以了，比如，将 0 号员工与 2 号员工交换。</p>
<p data-nodeid="332004">【<strong data-nodeid="332786">分析</strong>】初看这道题的时候，没有什么思路，那么我们进行一下模拟，看看能不能发现什么规律。</p>
<p data-nodeid="332005"><strong data-nodeid="332794">1</strong>. <strong data-nodeid="332795">模拟</strong></p>
<p data-nodeid="332006">当 N = 2 时，无论是 [0, 1] 还是 [1, 0] 这两种排列都满足要求，因为我们总是想让 [0, 1] 这两个员工坐在一起，而只有两个员工时，他们总是挨在一起的。假设结对成功的两个人坐在一起的时候，就像做在链条上的环一样。</p>
<p data-nodeid="332007">由于 N 必须为偶数，所以接下来我们看一下 N = 4 时的情况。比如 A = [0, 3, 2, 1]，此时 4 个人都没有结对成功，相当于两个环还扣一起。</p>
<p data-nodeid="332008">这时我们只需要交换 0, 2 形成 [2,3,0,1]，如果按配对划分，那就是 [2, 3] 和 [0, 1]。结对成功之后，这两个环就可以拆开了。操作如下图所示：</p>
<p data-nodeid="332009"><img src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZpeADOaKAADoS6Y44b0977.png" alt="Drawing 7.png" data-nodeid="332829"></p>
<p data-nodeid="336852" class="">通过这个示例，还可以发现，如果不经过交换，虽然 [3, 2] 这两个员工已经坐在一起了，但是不操作，那么 0 号员工和 1 号员工是无法结对编程的。</p>

<p data-nodeid="332011"><img src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZqCAfrFNAACU4aaiqjc231.png" alt="Drawing 8.png" data-nodeid="332837"></p>
<p data-nodeid="332012">因此，我们可以得到<strong data-nodeid="332859">结论 1：结对的时候，数组中只能偶数下标与奇数下标配比</strong>。比如 A[0] 与 A[1] 结对。不能奇数下标与偶数下标结对，比如 A[1] 与 A[2] 结对。</p>
<p data-nodeid="332013">接下来我们再看一下 N = 6 的情况， 比如 A = [0, 2, 3, 5, 1, 4]：我们在执行交换的时候，可以这样操作：</p>
<p data-nodeid="332014"><img src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZqqADNgZAAU5MW4PWoI242.gif" alt="2 (1).gif" data-nodeid="332867"></p>
<p data-nodeid="340198" class="te-preview-highlight">所以成功切分出三个配对集合 [0, 1], [3, 2], [5, 4]，需要 2 步。</p>

<p data-nodeid="332016"><strong data-nodeid="332888">2</strong>. <strong data-nodeid="332889">规律</strong></p>
<p data-nodeid="332017">通过前面的模拟，我们还需要进一步的总结规律。将里面没有成功结对的序列看成一条锁链。并且拆分出结对成功的两个元素，独立位于一个环中，并不与别人相扣在一起。</p>
<p data-nodeid="332018"><img src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZrSALzFBAADhm_fwnRk393.png" alt="Drawing 10.png" data-nodeid="332893"></p>
<p data-nodeid="332019">每 1 次操作，交换两个元素，就相当于从锁链中成功拆一个环下来。</p>
<p data-nodeid="332020"><img src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZryASSNEAAEb64nhdKE214.png" alt="Drawing 11.png" data-nodeid="332897"></p>
<p data-nodeid="332021">那么，我们可以得到<strong data-nodeid="332903">结论 2：有 2x 个元素，也就是 x 个环的锁链，就需要 x-1 次操作</strong>。</p>
<p data-nodeid="332022">至此，我们就将题目成功变成了：给定一个数组，需要找到里面有几条锁链。比如给定数组 A = [6, 4, 5, 2, 3, 7, 0, 1]。</p>
<p data-nodeid="332023">此时应该可以分出两条锁链来，如下图所示：</p>
<p data-nodeid="332024"><img src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZsWAPW0xAADZQU20JEU856.png" alt="Drawing 12.png" data-nodeid="332912"></p>
<p data-nodeid="332025">我们再看每个锁链中的环的数目就可以得到最少操作次数。比如这里的 A[] 数组有 2 条锁链，需要的操作次数是 (3 - 1) + (1-1) = 2。也就是最少操作 2 次。</p>
<p data-nodeid="332026">那么现在问题的关键就是，如何才能通过数组得到锁链呢？这里我们还发现一个有趣的<strong data-nodeid="332922">结论 3：本就结对的两个员工必然在同一个链条中</strong>。比如 6 和 5 在没有结对的情况下，也必然在同一条锁链中。</p>
<p data-nodeid="332027"><strong data-nodeid="332930">3</strong>. <strong data-nodeid="332931">匹配</strong></p>
<p data-nodeid="332028">如果将锁链当成集合，就可以对应到并查集了。这里再细化一下：</p>
<ul data-nodeid="332029">
<li data-nodeid="332030">
<p data-nodeid="332031">通过结论 3，我们应该将一个偶数 x 以及和它配对的数 x+1 先放到同一个集合中；</p>
</li>
<li data-nodeid="332032">
<p data-nodeid="332033">偶数下标 A[i]，需要与 A[i+1] 进行 Union，完成放到同一个锁链的操作。</p>
</li>
</ul>
<p data-nodeid="332034">虽然最后我们可以通过去数锁链中环的个数，再通过结论 2 得到答案。但是如果你能想到拆环的次数，实际上就是不同集合 Union 的次数。那么求解的时候，只需要在并查集模板的基础上对 Union 稍做更改就可以了。</p>
<p data-nodeid="332035"><strong data-nodeid="332951">4</strong>. <strong data-nodeid="332952">边界</strong></p>
<p data-nodeid="332036">注意处理空数组，注意结对的时候，要满足结论 1。</p>
<p data-nodeid="332037">【<strong data-nodeid="332963">画图</strong>】接下来我们画图演示一下使用并查集的过程。这里我们以数组 A = [6, 4, 5, 2, 3, 7, 0, 1] 为例。</p>
<p data-nodeid="332038"><img src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZteAaZlrABz3L57gQK4855.gif" alt="3.gif" data-nodeid="332966"></p>
<p data-nodeid="332039">我们发现，不同集合的合并次数一共为 2 次，所以只需要 2 次操作就可以完成结对编程的要求。</p>
<p data-nodeid="332040">【<strong data-nodeid="332973">代码</strong>】接下来我们可以写一下代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="332041"><code data-language="java"><span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">int</span> unionCount = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    <span class="hljs-comment">// 注意这里在初始化的时候</span>
    <span class="hljs-comment">// [0, 1]需要处在一个集合里面</span>
    <span class="hljs-comment">// 无论他们在数组里面是不是相邻</span>
    F[i] = i - (i &amp; <span class="hljs-number">0x01</span>);
  }
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">if</span> (x == F[x]) {
    <span class="hljs-keyword">return</span> x;
  }
  F[x] = Find(F[x]);
  <span class="hljs-keyword">return</span> F[x];
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  <span class="hljs-keyword">if</span> (Find(x) != Find(y)) {
    unionCount++;
  }
  F[Find(x)] = Find(y);
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  Init(N);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">2</span>) {
    Union(A[i], A[i + <span class="hljs-number">1</span>]);
  }
  <span class="hljs-keyword">return</span> unionCount;
}
</code></pre>
<blockquote data-nodeid="332042">
<p data-nodeid="332043">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332977">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332981">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="332985">Python</a></p>
</blockquote>
<p data-nodeid="332044"><strong data-nodeid="332990">复杂度分析</strong>：一共有 N/2 对元素要合并，每次合并的时间复杂度为 O(lgN)。所以时间复杂度为 O(NlgN)。</p>
<p data-nodeid="332045">【<strong data-nodeid="332996">小结</strong>】在这里，我们学习了将锁链处理成一个连通域，并且巧妙地通过求解合并次数解决了最小操作次数。</p>
<p data-nodeid="332046">我认为这道题目最核心的考点是分析出<strong data-nodeid="333006">结论 2</strong>：<strong data-nodeid="333007">有 2x 个元素，也就是 x 个环的锁链，就需要 x-1 次操作</strong>。</p>
<p data-nodeid="332047">一旦得到了每条锁链中的操作次数，然后利用并查集的模板，这道题目就解决了。我再给你留道练习题，希望你可以尝试做一下。</p>
<p data-nodeid="332048"><strong data-nodeid="333013">练习题 4</strong>：给定一个单词数组，如果两个单词相等，或者说其中一个单词 A 经过一次字符交换，可以得到单词 B，那么我们说单词 {A, B} 是同构的。请问单词数组中，一共有多少组这样的同构集合？</p>
<p data-nodeid="332049">输入：{"AB", "BA", "AB", "BC", "CD"}</p>
<p data-nodeid="332050">输出：3</p>
<p data-nodeid="332051"><strong data-nodeid="333060">解释</strong>：一共有三组同构集合，{"AB", "BA", "AB"}, {"BC"}, {"CD"}</p>
<blockquote data-nodeid="332052">
<p data-nodeid="332053">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/839.%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="333064">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/839.%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="333068">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/839.%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="333072">Python</a></p>
</blockquote>
<p data-nodeid="332054">接下来我们讲解并查集的进一步运用。</p>
<h3 data-nodeid="332055">虚拟点与虚拟边</h3>
<p data-nodeid="332056">在求解连通域的过程中，我们经常利用现有的点与现有的边进行并查集的初始化与合并。</p>
<p data-nodeid="332057">但是在有些题目中，需要加入一些<strong data-nodeid="333081">虚拟的边和虚拟的点</strong>到并查集的点集与边集中。通过这种方式可以极大地方便我们使用并查集。</p>
<h4 data-nodeid="332058">例 4: 替换字母</h4>
<p data-nodeid="332059">【<strong data-nodeid="333108">题目</strong>】给你一个矩阵 A，里面只包含字母 ‘O’ 和 'X'，如果一个 'O' 上下左右四周都被 'X' 包围，那么这个 'O' 会被替换成 'X'。请你写程序处理一下这个过程。</p>
<p data-nodeid="332060"><img src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZumAF_CYAAA1NGN0dU0625.png" alt="Drawing 14.png" data-nodeid="333111"></p>
<p data-nodeid="332061"><strong data-nodeid="333135">解释</strong>：由于中心的 'O' 四周都被包围，所以需要被换成 'X'，而第 A[0][0] = 'O' 靠着边，所以不能被替换。</p>
<p data-nodeid="332062">【<strong data-nodeid="333145">分析</strong>】这道题目曾经在<strong data-nodeid="333146">微软</strong>的面试中出现过。看起来就是一个连通域的问题，所以可以使用并查集来处理。思路如下：</p>
<ul data-nodeid="332063">
<li data-nodeid="332064">
<p data-nodeid="332065">首先用并查集标记所有 'O' 的连通域；</p>
</li>
<li data-nodeid="332066">
<p data-nodeid="332067">将所有在边上的 'O' 的“帮主”放到 set 集合中；</p>
</li>
<li data-nodeid="332068">
<p data-nodeid="332069">遍历每个 'O' 的“帮主”，看看是不是在 set 集合中，如果在，那么这个 'O' 不能替换。</p>
</li>
</ul>
<p data-nodeid="332070">可以发现，有一步操作可以优化：将所有在边上的 'O' 的“帮主”放到 set 集合中，有两种办法：</p>
<ul data-nodeid="332071">
<li data-nodeid="332072">
<p data-nodeid="332073">随便选择边上的一个点，作为所有边上点的“帮主”；</p>
</li>
<li data-nodeid="332074">
<p data-nodeid="332075">选一个虚拟的点，作为所有边上的点的“帮主”。</p>
</li>
</ul>
<p data-nodeid="332076">你可以根据自己的喜好任选其一，这里我用第 2 种“虚拟点”的办法。下面就可以直接套用模板了。</p>
<p data-nodeid="332077">【<strong data-nodeid="333179">代码</strong>】采用虚拟点的并查集的代码实现如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="332078"><code data-language="java"><span class="hljs-keyword">int</span>[][] dir = {{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">1</span>, <span class="hljs-number">0</span>}};
<span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    F[i] = i;
  }
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">if</span> (x == F[x]) {
    <span class="hljs-keyword">return</span> x;
  }
  F[x] = Find(F[x]);
  <span class="hljs-keyword">return</span> F[x];
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{ F[Find(x)] = Find(y); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] A)</span> </span>{
  <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span> || A[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> R = A.length;
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> C = A[<span class="hljs-number">0</span>].length;
  Init(R * C + <span class="hljs-number">1</span>);
  <span class="hljs-comment">// 我们将vNode设置为R * C</span>
  <span class="hljs-comment">// 这是一个在矩阵中不存在的点</span>
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> vNode = R * C;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; R; r++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; C; c++) {
      <span class="hljs-keyword">if</span> (A[r][c] == <span class="hljs-string">'O'</span>) {
        <span class="hljs-comment">// 如果是边上的点</span>
        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span> || r == R - <span class="hljs-number">1</span> || c == <span class="hljs-number">0</span> || c == C - <span class="hljs-number">1</span>) {
          <span class="hljs-comment">// 那么将其与vNode进行Union</span>
          Union(r * C + c, vNode);
        }
        <span class="hljs-comment">// 将其与四面的点进行Union</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">2</span>; d++) {
          <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nr = r + dir[d][<span class="hljs-number">0</span>];
          <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nc = c + dir[d][<span class="hljs-number">1</span>];
          <span class="hljs-keyword">if</span> (!(nr &lt; <span class="hljs-number">0</span> || nr &gt;= R || nc &lt; <span class="hljs-number">0</span> || nc &gt;= C)) {
            <span class="hljs-keyword">if</span> (A[nr][nc] == <span class="hljs-string">'O'</span>) {
              Union(r * C + c, nr * C + nc);
            }
          }
        }
      }
    }
  }
  <span class="hljs-comment">// 查看是不是和vNode一个集合，如果不是就要修改成'X'</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; R; r++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; C; c++) {
      <span class="hljs-keyword">if</span> (A[r][c] == <span class="hljs-string">'O'</span>) {
        <span class="hljs-keyword">if</span> (Find(r * C + c) != Find(vNode)) {
          A[r][c] = <span class="hljs-string">'X'</span>;
        }
      }
    }
  }
}
</code></pre>
<blockquote data-nodeid="332079">
<p data-nodeid="332080">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="333183">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="333187">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="333191">Python</a></p>
</blockquote>
<p data-nodeid="332081"><strong data-nodeid="333200">复杂度分析</strong>：由于每个点只遍历两遍。<strong data-nodeid="333201">所有点的数目为 N</strong>，所以时间复杂度为 O(NlgN)，此外，每个点都记录了所在集合，所以空间复杂度为 O(N)。</p>
<p data-nodeid="332082">【<strong data-nodeid="333207">小结</strong>】在这里我们学习了一种新的处理技巧，那就是利用并查集 + 虚拟结点，将原本不在一起的结点，统一放到了一个虚拟集合中。</p>
<p data-nodeid="332083">所以解决这道题目的考点我们可以总结如下：</p>
<p data-nodeid="332084"><img src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZvmACQxmAAC2H_g_eZk099.png" alt="Drawing 15.png" data-nodeid="333211"></p>
<p data-nodeid="332085">在面试中，如果你有了并查集的模板，再加上虚拟点的思路，那么快速解决这类问题就轻而易举了。</p>
<h4 data-nodeid="332086">例 5：上网的最小费用</h4>
<p data-nodeid="332087">【<strong data-nodeid="333229">题目</strong>】园区里面有很多大楼，编号从 1~N。第 i 大楼可以自己花钱买路由器上网，费用为 cost[i-1]，也可以从别的大楼拉一根网线来上网，比如大楼 a 和大楼 b 之间拉网线的费用为 c，表示为一条边 [a, b, c]。输入为每个大楼自己买路由器和拉网线的费用，请问，让所有大楼都能够上网的最小费用是多少？上网具有联通性，只要与能够上网的大楼连通，即可上网。</p>
<p data-nodeid="332088">输入：cost = [1, 2, 3], edges = [[1,2,100], [2,3,3]]</p>
<p data-nodeid="332089">输出：6</p>
<p data-nodeid="332090"><strong data-nodeid="333257">解释</strong>：最优方案是 1 号大楼买路由器 cost[0] = 1，2 号楼买路由器 cost[1] = 2，然后和 3 号楼之间可拉一根网线，费用为 3，所以一共花费 6 元。如图（红色部分标记为费用 ）：</p>
<p data-nodeid="332091"><img src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZwOAOXuWAABVP6uBCvA003.png" alt="Drawing 16.png" data-nodeid="333260"></p>
<p data-nodeid="332092">【<strong data-nodeid="333274">分析</strong>】这是一道<strong data-nodeid="333275">头条</strong>面试中出现过的题目。首先如果不考虑自己买路由器的情况，只依赖给定的边集构建这个图，且要求最小费用，这道题目就和最小生成树一模一样了。可是，这里与最小生成树不一样的地方在于：第 i 大楼可以自己花钱买路由器上网，费用为 cost[i-1]。</p>
<p data-nodeid="332093">在最小生成树里面，可是没有说“自己买路由”这个操作。那怎么办？我们有什么方法可以转化一下吗？</p>
<p data-nodeid="332094">可以采用加入虚拟点的方法。首先假设有一个结点 0 已经自己买了路由器，花费为 0 元。而其他结点要自己买路由器，本质等价于与结点 0 进行联通。只不过这个网线的费用，就是你自己买路由器的费用。</p>
<p data-nodeid="332095">比如，给定 3 个点，分别自己买路由器的费用为 [1, 2, 3]。那么我们可以把图变成下图这样子：</p>
<p data-nodeid="332096"><img src="https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZwyAA5MpAABxWS4ICiA231.png" alt="Drawing 17.png" data-nodeid="333285"></p>
<p data-nodeid="332097">也就是说，我们添加了一个虚拟结点 0，然后也添加了 3 条虚拟边。这里虚拟的元素我们都用绿色表示。</p>
<p data-nodeid="332098">如果最后生成的连通图里面把 0~3 这四个点都包含进去，那么所有的大楼肯定都是可以上网的。此时最小代价问题就可以用最小生成树的方法来解决了。</p>
<p data-nodeid="332099">【<strong data-nodeid="333295">代码</strong>】到这里，相信你已经知道可以怎么写代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="332100"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> totalCost = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 注意，编号是从1 ~ n</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
      F[i] = i;
    }
    totalCost = <span class="hljs-number">0</span>;
  }
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x == F[x]) {
      <span class="hljs-keyword">return</span> x;
    }
    F[x] = Find(F[x]);
    <span class="hljs-keyword">return</span> F[x];
  }
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> pay)</span> </span>{
    <span class="hljs-keyword">if</span> (Find(x) != Find(y)) {
      totalCost += pay;
    }
    F[Find(x)] = Find(y);
  }
  <span class="hljs-comment">// N 表示结点数目</span>
  <span class="hljs-comment">// cost[i-1]表示结点i自己买路由器的代价</span>
  <span class="hljs-comment">// es[x] = [a, b, c]表示大楼a,b之间拉网线的费用</span>
  <span class="hljs-comment">// 输出所有大楼通网的最小费用</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostToSupplyWater</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>[] cost, <span class="hljs-keyword">int</span>[][] es)</span> </span>{
    <span class="hljs-comment">// 初始化并查集</span>
    Init(N);
    <span class="hljs-comment">// 每个结点都要自己买路由器，那么我们可以认为这样</span>
    <span class="hljs-comment">// 0号楼已经有网络了，可以用0费用上网</span>
    <span class="hljs-comment">// i号楼与0号楼拉网线，需要的费用是cost[i-1]</span>
    <span class="hljs-comment">// 那么这里就多了N条边</span>
    <span class="hljs-keyword">int</span>[][] conn = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[es.length + N][<span class="hljs-number">3</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; es.length; i++) {
      conn[i][<span class="hljs-number">0</span>] = es[i][<span class="hljs-number">0</span>];
      conn[i][<span class="hljs-number">1</span>] = es[i][<span class="hljs-number">1</span>];
      conn[i][<span class="hljs-number">2</span>] = es[i][<span class="hljs-number">2</span>];
    }
    <span class="hljs-keyword">int</span> to = es.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) {
      conn[to][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
      conn[to][<span class="hljs-number">1</span>] = i;
      conn[to][<span class="hljs-number">2</span>] = cost[i - <span class="hljs-number">1</span>];
      to++;
    }
    <span class="hljs-comment">// 接下来采用Krukal最小生成树算法</span>
    Arrays.sort(conn, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() {
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>{
        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] - b[<span class="hljs-number">2</span>];
      }
    });
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; conn.length; i++) {
      Union(conn[i][<span class="hljs-number">0</span>], conn[i][<span class="hljs-number">1</span>], conn[i][<span class="hljs-number">2</span>]);
    }
    <span class="hljs-keyword">return</span> totalCost;
  }
}
</code></pre>
<blockquote data-nodeid="332101">
<p data-nodeid="332102">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="333299">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="333303">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="333307">Python</a></p>
</blockquote>
<p data-nodeid="332103"><strong data-nodeid="333312">复杂度分析</strong>： 一共有 N 个点，M 条边，N 个点进行 Find/Union 的时间复杂度为 O(lgN)，所以总的时间复杂度为 M(lgN)。</p>
<p data-nodeid="332104">【<strong data-nodeid="333318">小结</strong>】接下来我们从面试官的角度看一下，这道题的考点是什么：</p>
<ul data-nodeid="332105">
<li data-nodeid="332106">
<p data-nodeid="332107">将特殊条件转化为一般的条件，通过引入一些虚拟点，虚拟边来实现</p>
</li>
<li data-nodeid="332108">
<p data-nodeid="332109">并查集的模板代码</p>
</li>
<li data-nodeid="332110">
<p data-nodeid="332111">最小生成树的 Kruskal 算法</p>
</li>
</ul>
<p data-nodeid="332112">如果在面试中抓住了这 3 个点，就很容易击破这道算法题。接下来我们看一下并查集的另外一个的考点。</p>
<h3 data-nodeid="332113">路径压缩</h3>
<p data-nodeid="332114">并查集除了前面提到了考点之外，还有一个比较不容易出现的考点。那就是关于路径压缩的考点。</p>
<p data-nodeid="332115">处理这种题时，需要利用路径压缩同时将节点之间的信息进行层层压缩和汇总。求解过程还是很有趣的。下面让我们通过一个例题学习一下这个知识点。</p>
<h4 data-nodeid="332116">例 6: 倍数关系</h4>
<p data-nodeid="332117"><img src="https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZx2AJlAhAAB9L5EmBj8559.png" alt="Drawing 26.png" data-nodeid="333329"></p>
<p data-nodeid="332118">【<strong data-nodeid="333335">分析</strong>】那么首先我们进行一下模拟。</p>
<p data-nodeid="332119"><strong data-nodeid="333343">1</strong>. <strong data-nodeid="333344">模拟</strong></p>
<p data-nodeid="332120">变量之间的除法关系，我们需要记录一个链式信息。如果将除法当成一个有向边，然后变量与变量之间的除法就可以看成图结构。比如：<br>
<img src="https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZziAOXBLAAAF8Wyu_as055.png" alt="Drawing 30.png" data-nodeid="333349"><br>
可以表示为下图：</p>
<p data-nodeid="332121"><img src="https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZ0OAaHLpAABvAPNQMEI372.png" alt="Drawing 31.png" data-nodeid="333354"></p>
<p data-nodeid="332122">如果我们将上图进行压缩，那么可以得到下图：</p>
<p data-nodeid="332123"><img src="https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZ02AEcbFAABhq26WhTE347.png" alt="Drawing 32.png" data-nodeid="333358"></p>
<p data-nodeid="332124">经过压缩之后，可以发现这几个元素之间的关系就变成了下面这个样子：</p>
<ul data-nodeid="332125">
<li data-nodeid="332126">
<p data-nodeid="332127">a = 8 * c</p>
</li>
<li data-nodeid="332128">
<p data-nodeid="332129">c = 1 * c</p>
</li>
<li data-nodeid="332130">
<p data-nodeid="332131">b = 4 * c</p>
</li>
</ul>
<p data-nodeid="332132">此时，可以得到任意两个变量之间的比值。实际上，这几个数也可以以 a 元素为根，如下图所示：</p>
<p data-nodeid="332133"><img src="https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZ1qASIekAAC-iYLl5-E217.png" alt="Drawing 33.png" data-nodeid="333372"></p>
<p data-nodeid="332134">几个元素之间的关系就是这样：</p>
<ul data-nodeid="332135">
<li data-nodeid="332136">
<p data-nodeid="332137">b = 0.5 * a</p>
</li>
<li data-nodeid="332138">
<p data-nodeid="332139">a = 1 * a</p>
</li>
<li data-nodeid="332140">
<p data-nodeid="332141">c = 0.125 * a</p>
</li>
</ul>
<p data-nodeid="332142">此时，我们可以得到任意两个变量之间的比值。</p>
<p data-nodeid="332143"><strong data-nodeid="333391">2</strong>. <strong data-nodeid="333392">规律</strong></p>
<p data-nodeid="332144">在这里，可以通过模拟找到一个<strong data-nodeid="333398">规律：只要是相连通的几个元素，可以选择任意一个结点做根结点。连通性好办，重点是：需要记录元素与根元素的比例</strong>。</p>
<p data-nodeid="332145">并且我们发现其实哪个点做根结点都一样。但是比例关系怎么办？再回看一下模拟的过程，可以发现：<strong data-nodeid="333404">比例关系就是顺着图中，有向边的方向乘过去即可</strong>。</p>
<p data-nodeid="332146">这里我们画图表示如下：</p>
<p data-nodeid="332147"><img src="https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZ2WAYuNmAADbi_WkYTo775.png" alt="Drawing 34.png" data-nodeid="333408"></p>
<p data-nodeid="332148">也就是说，在压缩的时候，需要把路径上边的权重依次乘起来。</p>
<p data-nodeid="332149"><strong data-nodeid="333417">3</strong>. <strong data-nodeid="333418">匹配</strong></p>
<p data-nodeid="332150">通过前面的一番分析，可以发现题目具有两个特点：</p>
<ul data-nodeid="332151">
<li data-nodeid="332152">
<p data-nodeid="332153">连通性</p>
</li>
<li data-nodeid="332154">
<p data-nodeid="332155">路径压缩性</p>
</li>
</ul>
<p data-nodeid="332156">能匹配到这两个特点的算法刚好是今天所讲的并查集。</p>
<p data-nodeid="332157"><strong data-nodeid="333430">4</strong>. <strong data-nodeid="333431">边界</strong></p>
<p data-nodeid="332158"><strong data-nodeid="333440">面试官提醒</strong>：<strong data-nodeid="333441">由于涉及除法，在面试中，你一定要主动提出是否可能存在除 0 的情况。如果给定的输入里面可能有，那么一定要记得处理</strong>。</p>
<p data-nodeid="332159">【<strong data-nodeid="333447">代码</strong>】我们已经有了并查集的代码，那么处理路径压缩，应该也不是什么问题，代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="332160"><code data-language="java"><span class="hljs-comment">// 小技巧：</span>
<span class="hljs-comment">// 记录字符串与整数的映射</span>
<span class="hljs-comment">// 将字符串映射成整数之后，在操作并查集的数组的时候</span>
<span class="hljs-comment">// 我们就可以使用整数组，速度也更快。</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addToMap</span><span class="hljs-params">(String key, Map&lt;String, Integer&gt; H)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id = H.size();
  <span class="hljs-keyword">if</span> (!H.containsKey(key)) {
    H.put(key, id);
  }
}
<span class="hljs-comment">// 并查集的数组 </span>
<span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
<span class="hljs-comment">// 结点与其父结点的比例关系，我们总是用子结点除以父结点</span>
<span class="hljs-comment">// 当 a / c = 8时，并且当前 a的父结点就是c</span>
<span class="hljs-comment">// 那么 C[a] = 8</span>
<span class="hljs-comment">// 当并查集的结构调整之后，a的父结点变成了d</span>
<span class="hljs-comment">// 并且a/d=16，那么此时C[a] = 16</span>
<span class="hljs-keyword">double</span>[] C = <span class="hljs-keyword">null</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
  C = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[n];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    F[i] = i;
    C[i] = <span class="hljs-number">1</span>;
  }
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">int</span> b = x;
  <span class="hljs-comment">// base用来保存从x -&gt; .... root</span>
  <span class="hljs-comment">// 这条路径上所有的乘积</span>
  <span class="hljs-comment">// 最后保证可以得到</span>
  <span class="hljs-comment">// x = base * root</span>
  <span class="hljs-keyword">double</span> base = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (x != F[x]) {
    base *= C[x];
    x = F[x];
  }
  <span class="hljs-comment">// 这里x就是root</span>
  <span class="hljs-comment">// base x -&gt; root的映射值</span>
  <span class="hljs-comment">// 把路径上的其他值一并压缩</span>
  <span class="hljs-keyword">int</span> root = x;
  <span class="hljs-keyword">while</span> (F[b] != root) {
    <span class="hljs-comment">// 修改值上的变化</span>
    <span class="hljs-keyword">double</span> next = base / C[b];
    C[b] = base;
    base = next;
    <span class="hljs-keyword">int</span> par = F[b];
    F[b] = root;
    b = par;
  }
  <span class="hljs-keyword">return</span> root;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> T, <span class="hljs-keyword">int</span> D, <span class="hljs-keyword">double</span> v)</span> </span>{
  <span class="hljs-comment">// T / D = v;</span>
  <span class="hljs-comment">// 给定的输入表示 T = v * D;</span>
  <span class="hljs-comment">// 那么找到T的root</span>
  <span class="hljs-keyword">int</span> tpar = Find(T);
  <span class="hljs-comment">// T = C[T] * par</span>
  <span class="hljs-keyword">int</span> dpar = Find(D);
  <span class="hljs-comment">// D = C[D] * dpar;</span>
  <span class="hljs-comment">// T = v * D = v * C[D] * dpar = C[T] * tpar;</span>
  <span class="hljs-comment">// 如果我们要让tpar 指向dpar</span>
  <span class="hljs-comment">// tpar = v * C[D] * dpar / C[T]</span>
  F[tpar] = dpar;
  C[tpar] = v * C[D] / C[T];
}
<span class="hljs-keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations,
                       <span class="hljs-keyword">double</span>[] values,
                       List&lt;List&lt;String&gt;&gt; queries) {
  <span class="hljs-comment">// 为了方便后面操作，我们把所有的字符串都映射成整数</span>
  Map&lt;String, Integer&gt; H = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
  <span class="hljs-keyword">for</span> (List&lt;String&gt; l : equations) {
    String t = l.get(<span class="hljs-number">0</span>), d = l.get(<span class="hljs-number">1</span>);
    addToMap(t, H);
    addToMap(d, H);
  }
  <span class="hljs-comment">// 初始化并查集</span>
  Init(H.size());
  <span class="hljs-comment">// 开始执行Union操作</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; equations.size(); i++) {
    List&lt;String&gt; l = equations.get(i);
    Union(H.get(l.get(<span class="hljs-number">0</span>)), H.get(l.get(<span class="hljs-number">1</span>)), values[i]);
  }
  <span class="hljs-comment">// 在进行query之前，对所有的点执行Find操作。让后面的query</span>
  <span class="hljs-comment">// 的Find操作时间复杂度为O(1)</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; H.size(); i++) {
    Find(i);
  }
  <span class="hljs-keyword">double</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[queries.size()];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; queries.size(); i++) {
    List&lt;String&gt; l = queries.get(i);
    <span class="hljs-keyword">int</span> tidx = H.containsKey(l.get(<span class="hljs-number">0</span>)) ? H.get(l.get(<span class="hljs-number">0</span>)) : -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> didx = H.containsKey(l.get(<span class="hljs-number">1</span>)) ? H.get(l.get(<span class="hljs-number">1</span>)) : -<span class="hljs-number">1</span>;
    <span class="hljs-comment">// 如果变量不存在，那么比例关系照题意设置为-1</span>
    <span class="hljs-keyword">if</span> (tidx == -<span class="hljs-number">1</span> || didx == -<span class="hljs-number">1</span>) {
      ans[i] = -<span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">int</span> troot = Find(tidx);
      <span class="hljs-keyword">int</span> droot = Find(didx);
      <span class="hljs-comment">// 如果两个变量从来没有过交集 </span>
      <span class="hljs-keyword">if</span> (troot != droot) {
        ans[i] = -<span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        ans[i] = C[tidx] / C[didx];
      }
    }
  }
  <span class="hljs-keyword">return</span> ans;
}
</code></pre>
<blockquote data-nodeid="332161">
<p data-nodeid="332162">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="333451">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="333455">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="333459">Python</a></p>
</blockquote>
<p data-nodeid="332163"><strong data-nodeid="333464">复杂度分析</strong>：假设有 N 个变量，构建并查集的时间复杂度为 O (NlgN)，如果有 M 个 Query，每次在询问为 O(1)，所以总的时间复杂度为 max(O(NlgN),M)。</p>
<p data-nodeid="332164">【<strong data-nodeid="333470">小结</strong>】如果要解决这道题，那么需要注意掌握以下三点。</p>
<ul data-nodeid="332165">
<li data-nodeid="332166">
<p data-nodeid="332167">连通域里面的所有变量都统一用一个变量表示倍数关系，那么任意的两个变量就可以直接询问倍数关系。</p>
</li>
<li data-nodeid="332168">
<p data-nodeid="332169">倍数关系具有传递性，即：<br>
<img src="https://uploader.shimo.im/f/LbdIya2siEFX52pW.png!thumbnail?fileGuid=xxQTRXtVcqtHK6j8" alt="图片" data-nodeid="333476"><br>
这是我们进行路径压缩的关键。</p>
</li>
<li data-nodeid="332170">
<p data-nodeid="332171">Union 操作时，注意变量倍数关系的调整。</p>
</li>
</ul>
<p data-nodeid="332172">如果想到了这些，再加上我介绍的并查集的代码模板，那么解决这道面试题也就没什么难度了。以后在面试中，你如果发现题目具有<strong data-nodeid="333485">传递性</strong>的特点，就可以使用并查集进行求解。</p>
<h3 data-nodeid="332173">总结</h3>
<p data-nodeid="332174">在本讲中，我介绍了并查集面试时常见的考察点，并且给出了并查集的代码模板。最后我还给你准备了并查集的知识树，面试中并查集相关的问题基本上逃不出这个圈。希望你可以尝试自己对本讲的内容进行梳理，然后再对照下图查缺补漏。</p>
<p data-nodeid="332175"><img src="https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZ5KACZb3AAEzzay3PAM503.png" alt="Drawing 38.png" data-nodeid="333490"></p>
<h3 data-nodeid="332176">思考题</h3>
<p data-nodeid="332177">如果我们把例 5 的变量看成图上的点，变量与变量之间的关系看成是边。一旦构建好了并查集，在 Query 的时候，就可以 O(1) 的时间查询到两个变量之间的代价。那么为什么在图算法中，我们需要用 Floyd 算法求解图中两个点之间的最短路径？</p>
<p data-nodeid="332178">希望你可以把思考写在留言区，我们一起讨论，如果看到有趣的想法，我也会做成加餐和大家分享。：）</p>
<p data-nodeid="332179" class="">到这里，我们就要与并查集说再见了，接下来我们一起学习 08｜排序：如何利用合并与快排的小技巧，解决算法难题。记得按时来探险。</p>